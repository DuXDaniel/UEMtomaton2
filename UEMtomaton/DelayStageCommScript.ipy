import sys
import time
import threading
sys.path.append(r'C:\Windows\Microsoft.NET\assembly\GAC_64\Newport.XPS.CommandInterface\v4.0_1.0.0.0__9a267756cf640dcf')
# The CLR module provide functions for interacting with the underlying
# .NET runtime
import clr
# Add reference to assembly and import names from namespace (IronPython) 
clr.AddReferenceToFile("Newport.XPS.CommandInterface.dll") from CommandInterfaceXPS import *

# Create XPS interface with myXPS = XPS()

class XPSObj(object):
    checkLoop = 0

    def XPS_Open (self, address, port):
        # Create XPS interface
        self.myXPS = XPS()
        # Open a socket
        timeout = 1000
        result = self.myXPS.OpenInstrument(address, port, timeout)
        if result == 0:
            print 'Open ', address, ":", port, " => Successful"
        else:
            print 'Open ', address, ":", port, " => failure ", result
        
        f = open('/connectStatFile.txt', 'w')
        f.write('1')
        f.close()

    def XPS_MoveController (self):
        result, errString = self.myXPS.MoveAbsolute(x)# add arguments in microns
        return result, errString

    def XPS_GetControllerState (self):
        result, state, errString = self.myXPS.ControllerStatusGet()
        return result, state

    def XPS_Close(self,myXPS):
        self.myXPS.CloseInstrument()
        f = open('/connectStatFile.txt', 'w')
        f.write('0')
        f.close()

    def processMovementFile():
        f = open('/movementCommFile.txt','r')
        posMov = float(f.readline())
        compStat = int(f.readline())
        f.close()

        return posMov, compStat

    def indicateCompletedMovement():
        f = open('/movementCommFile.txt','w')
        f.write(str(posMov))
        f.write('1')
        f.close()

    def checkDisconnectOrder():
        f = open('/connectStatFile.txt','r')
        checker = int(f.readline())
        f.close()
        return checker

    def signalPosition(self): # async
        while(self.myXPS.IsDeviceConnected() and self.checkLoop != 2): # have a more rigorous method to kill the thread
            f = open('/positionFile.txt','w')
            f.write(str(self.myXPS.GetCurrentPosition())) #is this the correct function?
            f.close()
            time.sleep(0.1) # pause every 100 ms, don't need the crazy granularity

    def orderLoop(self): #async
        while(self.myXPS.IsDeviceConnected() and self.checkLoop != 2): # have a more rigorous method to kill the thread
            posMov, compStat = self.processMovementFile()
            if (compStat == 0):
                self.XPS_MoveController(self.myXPS, posMov) # move the controller to posMov in microns
                result = self.myXPS.WaitMotionEnd(60000, y_end_um, x_end_um)
                self.indicateCompletedMovement()
            time.sleep(0.1) # pause every 100 ms, don't need the crazy granularity

    def initOrderLoop(self):
        self._orderLoop_thread = threading.Thread(target=self.orderLoop, args=(self.myXPS))
        self._orderLoop_thread.daemon = True
        self._orderLoop_thread.start()

    def initSignalPos(self):
        self._signalPosition_thread = threading.Thread(target=self.signalPosition, args=(self.myXPS))
        self._signalPosition_thread.daemon = True
        self._signalPosition_thread.start()

def main(argv):
    controlXPS = XPSObj()
    controlXPS.XPS_Open(address, port)
    controlXPS.initOrderLoop()
    controlXPS.initSignalPos()

    checkLoop = controlXPS.checkDisconnectOrder()

    while (checkLoop != 2):
        checkLoop = controlXPS.checkDisconnectOrder()
        if (checkLoop == 2):
            controlXPS.checkLoop = 2
        time.sleep(0.5)

if __name__ == '__main__':
    main(sys.argv)